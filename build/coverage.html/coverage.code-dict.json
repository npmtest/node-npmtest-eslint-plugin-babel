{"/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/test.js":"/* istanbul instrument in package npmtest_eslint_plugin_babel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/lib.npmtest_eslint_plugin_babel.js":"/* istanbul instrument in package npmtest_eslint_plugin_babel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_eslint_plugin_babel = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_eslint_plugin_babel = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-eslint-plugin-babel && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_eslint_plugin_babel */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_eslint_plugin_babel\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_eslint_plugin_babel.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_eslint_plugin_babel.rollup.js'] =\n            local.assetsDict['/assets.npmtest_eslint_plugin_babel.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_eslint_plugin_babel.__dirname + '/lib.npmtest_eslint_plugin_babel.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/index.js":"'use strict';\n\nmodule.exports = {\n  rules: {\n    'generator-star-spacing': require('./rules/generator-star-spacing'),\n    'new-cap': require('./rules/new-cap'),\n    'object-curly-spacing': require('./rules/object-curly-spacing'),\n    'array-bracket-spacing': require('./rules/array-bracket-spacing'),\n    'object-shorthand': require('./rules/object-shorthand'),\n    'arrow-parens': require('./rules/arrow-parens'),\n    'no-await-in-loop': require('./rules/no-await-in-loop'),\n    'flow-object-type': require('./rules/flow-object-type'),\n    'func-params-comma-dangle': require('./rules/func-params-comma-dangle'),\n    'no-invalid-this': require('./rules/no-invalid-this'),\n    'semi': require('./rules/semi'),\n  },\n  rulesConfig: {\n    'generator-star-spacing': 0,\n    'new-cap': 0,\n    'object-curly-spacing': 0,\n    'array-bracket-spacing': 0,\n    'object-shorthand': 0,\n    'arrow-parens': 0,\n    'no-await-in-loop': 0,\n    'flow-object-type': 0,\n    'func-params-comma-dangle': 0,\n    'no-invalid-this': 0,\n    'semi': 0,\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/generator-star-spacing.js":"\"use strict\";\n\nvar isWarnedForDeprecation = false;\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        schema: [\n            {\n                \"oneOf\": [\n                    {\n                        \"enum\": [\"before\", \"after\", \"both\", \"neither\"]\n                    },\n                    {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"before\": {\"type\": \"boolean\"},\n                            \"after\": {\"type\": \"boolean\"}\n                        },\n                        \"additionalProperties\": false\n                    }\n                ]\n            }\n        ]\n    },\n    create: function() {\n        return {\n            Program: function() {\n                if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n                    return;\n                }\n\n                /* eslint-disable no-console */\n                console.log('The babel/generator-star-spacing rule is deprecated. Please ' +\n                            'use the built in generator-star-spacing rule instead.');\n                /* eslint-enable no-console */\n                isWarnedForDeprecation = true;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/new-cap.js":"/**\n * @fileoverview Rule to flag use of constructors without capital letters\n * @author Nicholas C. Zakas\n * @copyright 2014 Jordan Harband. All rights reserved.\n * @copyright 2013-2014 Nicholas C. Zakas. All rights reserved.\n * @copyright 2015 Mathieu M-Gosselin. All rights reserved.\n */\n\n\"use strict\";\n\nvar CAPS_ALLOWED = [\n    \"Array\",\n    \"Boolean\",\n    \"Date\",\n    \"Error\",\n    \"Function\",\n    \"Number\",\n    \"Object\",\n    \"RegExp\",\n    \"String\",\n    \"Symbol\"\n];\n\n/**\n * Ensure that if the key is provided, it must be an array.\n * @param {Object} obj Object to check with `key`.\n * @param {string} key Object key to check on `obj`.\n * @param {*} fallback If obj[key] is not present, this will be returned.\n * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`\n */\nfunction checkArray(obj, key, fallback) {\n    /* istanbul ignore if */\n    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {\n        throw new TypeError(key + \", if provided, must be an Array\");\n    }\n    return obj[key] || fallback;\n}\n\n/**\n * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.\n * @param {Object} map Accumulator object for the reduce.\n * @param {string} key Object key to set to `true`.\n * @returns {Object} Returns the updated Object for further reduction.\n */\nfunction invert(map, key) {\n    map[key] = true;\n    return map;\n}\n\n/**\n * Creates an object with the cap is new exceptions as its keys and true as their values.\n * @param {Object} config Rule configuration\n * @returns {Object} Object with cap is new exceptions.\n */\nfunction calculateCapIsNewExceptions(config) {\n    var capIsNewExceptions = checkArray(config, \"capIsNewExceptions\", CAPS_ALLOWED);\n\n    if (capIsNewExceptions !== CAPS_ALLOWED) {\n        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);\n    }\n\n    return capIsNewExceptions.reduce(invert, {});\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n\n    var config = context.options[0] || {};\n    var NEW_IS_CAP = config.newIsCap !== false;\n    var CAP_IS_NEW = config.capIsNew !== false;\n\n    var newIsCapExceptions = checkArray(config, \"newIsCapExceptions\", []).reduce(invert, {});\n\n    var capIsNewExceptions = calculateCapIsNewExceptions(config);\n\n    var listeners = {};\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Get exact callee name from expression\n     * @param {ASTNode} node CallExpression or NewExpression node\n     * @returns {string} name\n     */\n    function extractNameFromExpression(node) {\n\n        var name = \"\",\n            property;\n\n        if (node.callee.type === \"MemberExpression\") {\n            property = node.callee.property;\n\n            if (property.type === \"Literal\" && (typeof property.value === \"string\")) {\n                name = property.value;\n            } else if (property.type === \"Identifier\" && !node.callee.computed) {\n                name = property.name;\n            }\n        } else {\n            name = node.callee.name;\n        }\n        return name;\n    }\n\n    /**\n     * Returns the capitalization state of the string -\n     * Whether the first character is uppercase, lowercase, or non-alphabetic\n     * @param {string} str String\n     * @returns {string} capitalization state: \"non-alpha\", \"lower\", or \"upper\"\n     */\n    function getCap(str) {\n        var firstChar = str.charAt(0);\n\n        var firstCharLower = firstChar.toLowerCase();\n        var firstCharUpper = firstChar.toUpperCase();\n\n        if (firstCharLower === firstCharUpper) {\n            // char has no uppercase variant, so it's non-alphabetic\n            return \"non-alpha\";\n        } else if (firstChar === firstCharLower) {\n            return \"lower\";\n        } else {\n            return \"upper\";\n        }\n    }\n\n    /**\n     * Returns whether a node is under a decorator or not.\n     * @param  {ASTNode}  node CallExpression node\n     * @returns {Boolean} Returns true if the node is under a decorator.\n     */\n    function isDecorator(node) {\n        return node.parent.type === \"Decorator\";\n    }\n\n    /**\n     * Check if capitalization is allowed for a CallExpression\n     * @param {Object} allowedMap Object mapping calleeName to a Boolean\n     * @param {ASTNode} node CallExpression node\n     * @param {string} calleeName Capitalized callee name from a CallExpression\n     * @returns {Boolean} Returns true if the callee may be capitalized\n     */\n    function isCapAllowed(allowedMap, node, calleeName) {\n        if (allowedMap[calleeName] || allowedMap[context.getSource(node.callee)]) {\n            return true;\n        }\n        if (calleeName === \"UTC\" && node.callee.type === \"MemberExpression\") {\n            // allow if callee is Date.UTC\n            return node.callee.object.type === \"Identifier\" &&\n                node.callee.object.name === \"Date\";\n        }\n        return false;\n    }\n\n    /**\n     * Reports the given message for the given node. The location will be the start of the property or the callee.\n     * @param {ASTNode} node CallExpression or NewExpression node.\n     * @param {string} message The message to report.\n     * @returns {void}\n     */\n    function report(node, message) {\n        var callee = node.callee;\n\n        if (callee.type === \"MemberExpression\") {\n            callee = callee.property;\n        }\n\n        context.report(node, callee.loc.start, message);\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    if (NEW_IS_CAP) {\n        listeners.NewExpression = function(node) {\n\n            var constructorName = extractNameFromExpression(node);\n            if (constructorName) {\n                var capitalization = getCap(constructorName);\n                var isAllowed = capitalization !== \"lower\" || isCapAllowed(newIsCapExceptions, node, constructorName);\n                if (!isAllowed) {\n                    report(node, \"A constructor name should not start with a lowercase letter.\");\n                }\n            }\n        };\n    }\n\n    if (CAP_IS_NEW) {\n        listeners.CallExpression = function(node) {\n\n            var calleeName = extractNameFromExpression(node);\n            if (calleeName) {\n                var capitalization = getCap(calleeName);\n                var isAllowed = capitalization !== \"upper\" || isDecorator(node) || isCapAllowed(capIsNewExceptions, node, calleeName);\n                if (!isAllowed) {\n                    report(node, \"A function with a name starting with an uppercase letter should only be used as a constructor.\");\n                }\n            }\n        };\n    }\n\n    return listeners;\n};\n\nmodule.exports.schema = [\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"newIsCap\": {\n                \"type\": \"boolean\"\n            },\n            \"capIsNew\": {\n                \"type\": \"boolean\"\n            },\n            \"newIsCapExceptions\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"string\"\n                }\n            },\n            \"capIsNewExceptions\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"string\"\n                }\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/object-curly-spacing.js":"/**\n * @fileoverview Disallows or enforces spaces inside of object literals.\n * @author Jamund Ferguson\n * @copyright 2014 Brandyn Bennett. All rights reserved.\n * @copyright 2014 Michael Ficarra. No rights reserved.\n * @copyright 2014 Vignesh Anand. All rights reserved.\n * @copyright 2015 Jamund Ferguson. All rights reserved.\n * @copyright 2015 Mathieu M-Gosselin. All rights reserved.\n * @copyright 2015 Toru Nagashima. All rights reserved.\n * See LICENSE file in root directory for full license.\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = function(context) {\n    var spaced = context.options[0] === \"always\",\n        sourceCode = context.getSourceCode();\n\n    /**\n     * Determines whether an option is set, relative to the spacing option.\n     * If spaced is \"always\", then check whether option is set to false.\n     * If spaced is \"never\", then check whether option is set to true.\n     * @param {Object} option - The option to exclude.\n     * @returns {boolean} Whether or not the property is excluded.\n     */\n    function isOptionSet(option) {\n        return context.options[1] != null ? context.options[1][option] === !spaced : false;\n    }\n\n    var options = {\n        spaced: spaced,\n        arraysInObjectsException: isOptionSet(\"arraysInObjects\"),\n        objectsInObjectsException: isOptionSet(\"objectsInObjects\")\n    };\n\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Determines whether two adjacent tokens are have whitespace between them.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not there is space between the tokens.\n     */\n    function isSpaced(left, right) {\n        return sourceCode.isSpaceBetweenTokens(left, right);\n    }\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     */\n    function isSameLine(left, right) {\n        return left.loc.start.line === right.loc.start.line;\n    }\n\n    /**\n    * Reports that there shouldn't be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoBeginningSpace(node, token) {\n        context.report({\n            node: node,\n            loc: token.loc.end,\n            message: \"There should be no space after '\" + token.value + \"'\",\n            fix: function(fixer) {\n                var nextToken = sourceCode.getTokenAfter(token);\n                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n            }\n        });\n    }\n\n    /**\n    * Reports that there shouldn't be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoEndingSpace(node, token) {\n        context.report({\n            node: node,\n            loc: token.loc.start,\n            message: \"There should be no space before '\" + token.value + \"'\",\n            fix: function(fixer) {\n                var previousToken = sourceCode.getTokenBefore(token);\n                return fixer.removeRange([previousToken.range[1], token.range[0]]);\n            }\n        });\n    }\n\n    /**\n    * Reports that there should be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportRequiredBeginningSpace(node, token) {\n        context.report({\n            node: node,\n            loc: token.loc.end,\n            message: \"A space is required after '\" + token.value + \"'\",\n            fix: function(fixer) {\n                return fixer.insertTextAfter(token, \" \");\n            }\n        });\n    }\n\n    /**\n    * Reports that there should be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportRequiredEndingSpace(node, token) {\n        context.report({\n            node: node,\n            loc: token.loc.start,\n            message: \"A space is required before '\" + token.value + \"'\",\n            fix: function(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n            }\n        });\n    }\n\n    /**\n     * Determines if spacing in curly braces is valid.\n     * @param {ASTNode} node The AST node to check.\n     * @param {Token} first The first token to check (should be the opening brace)\n     * @param {Token} second The second token to check (should be first after the opening brace)\n     * @param {Token} penultimate The penultimate token to check (should be last before closing brace)\n     * @param {Token} last The last token to check (should be closing brace)\n     * @returns {void}\n     */\n    function validateBraceSpacing(node, first, second, penultimate, last) {\n        var closingCurlyBraceMustBeSpaced =\n            options.arraysInObjectsException && penultimate.value === \"]\" ||\n            options.objectsInObjectsException && penultimate.value === \"}\"\n                ? !options.spaced : options.spaced;\n\n        if (isSameLine(first, second)) {\n            if (options.spaced && !isSpaced(first, second)) {\n                reportRequiredBeginningSpace(node, first);\n            }\n            if (!options.spaced && isSpaced(first, second)) {\n                reportNoBeginningSpace(node, first);\n            }\n        }\n\n        if (isSameLine(penultimate, last)) {\n            if (closingCurlyBraceMustBeSpaced && !isSpaced(penultimate, last)) {\n                reportRequiredEndingSpace(node, last);\n            }\n            if (!closingCurlyBraceMustBeSpaced && isSpaced(penultimate, last)) {\n                reportNoEndingSpace(node, last);\n            }\n        }\n    }\n\n    /**\n     * Reports a given object node if spacing in curly braces is invalid.\n     * @param {ASTNode} node - An ObjectExpression or ObjectPattern node to check.\n     * @returns {void}\n     */\n    function checkForObject(node) {\n        if (node.properties.length === 0) {\n            return;\n        }\n\n        var firstSpecifier = node.properties[0],\n            lastSpecifier = node.properties[node.properties.length - 1];\n\n        var first = sourceCode.getTokenBefore(firstSpecifier),\n            last = sourceCode.getTokenAfter(lastSpecifier);\n\n        // support trailing commas\n        if (last.value === \",\") {\n            last = sourceCode.getTokenAfter(last);\n        }\n\n        var second = sourceCode.getTokenAfter(first),\n            penultimate = sourceCode.getTokenBefore(last);\n\n        validateBraceSpacing(node, first, second, penultimate, last);\n    }\n\n    /**\n     * Reports a given import node if spacing in curly braces is invalid.\n     * @param {ASTNode} node - An ImportDeclaration node to check.\n     * @returns {void}\n     */\n    function checkForImport(node) {\n        if (node.specifiers.length === 0) {\n            return;\n        }\n\n        var firstSpecifier = node.specifiers[0],\n            lastSpecifier = node.specifiers[node.specifiers.length - 1];\n\n        if (lastSpecifier.type !== \"ImportSpecifier\") {\n            return;\n        }\n        if (firstSpecifier.type !== \"ImportSpecifier\") {\n            firstSpecifier = node.specifiers[1];\n        }\n\n        var first = sourceCode.getTokenBefore(firstSpecifier),\n            last = sourceCode.getTokenAfter(lastSpecifier);\n\n        // to support a trailing comma.\n        if (last.value === \",\") {\n            last = sourceCode.getTokenAfter(last);\n        }\n\n        var second = sourceCode.getTokenAfter(first),\n            penultimate = sourceCode.getTokenBefore(last);\n\n        validateBraceSpacing(node, first, second, penultimate, last);\n    }\n\n    /**\n     * Reports a given export node if spacing in curly braces is invalid.\n     * @param {ASTNode} node - An ExportNamedDeclaration node to check.\n     * @returns {void}\n     */\n    function checkForExport(node) {\n        if (node.specifiers.length === 0) {\n            return;\n        }\n\n        var firstSpecifier = node.specifiers[0],\n            lastSpecifier = node.specifiers[node.specifiers.length - 1],\n            first = sourceCode.getTokenBefore(firstSpecifier),\n            last = sourceCode.getTokenAfter(lastSpecifier);\n\n        // export * as x from '...';\n        // export x from '...';\n        if (first.value === \"export\") {\n            return;\n        }\n\n        // to support a trailing comma.\n        if (last.value === \",\") {\n            last = sourceCode.getTokenAfter(last);\n        }\n\n        var second = sourceCode.getTokenAfter(first),\n            penultimate = sourceCode.getTokenBefore(last);\n\n        validateBraceSpacing(node, first, second, penultimate, last);\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n        // var {x} = y;\n        ObjectPattern: checkForObject,\n\n        // var y = {x: 'y'}\n        ObjectExpression: checkForObject,\n\n        // import {y} from 'x';\n        ImportDeclaration: checkForImport,\n\n        // export {name} from 'yo';\n        ExportNamedDeclaration: checkForExport\n    };\n\n};\n\nmodule.exports.schema = [\n    {\n        \"enum\": [\"always\", \"never\"]\n    },\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"arraysInObjects\": {\n                \"type\": \"boolean\"\n            },\n            \"objectsInObjects\": {\n                \"type\": \"boolean\"\n            }\n        },\n        \"additionalProperties\": false\n    }\n];\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/array-bracket-spacing.js":"\"use strict\";\n\nvar isWarnedForDeprecation = false;\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        schema: [\n            {\n                \"enum\": [\"always\", \"never\"]\n            },\n            {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"singleValue\": {\n                        \"type\": \"boolean\"\n                    },\n                    \"objectsInArrays\": {\n                        \"type\": \"boolean\"\n                    },\n                    \"arraysInArrays\": {\n                        \"type\": \"boolean\"\n                    }\n                },\n                \"additionalProperties\": false\n            }\n        ]\n    },\n    create: function() {\n        return {\n            Program: function() {\n                if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n                    return;\n                }\n\n                /* eslint-disable no-console */\n                console.log('The babel/array-bracket-spacing rule is deprecated. Please ' +\n                            'use the built in array-bracket-spacing rule instead.');\n                /* eslint-enable no-console */\n                isWarnedForDeprecation = true;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/object-shorthand.js":"\"use strict\";\n\nvar isWarnedForDeprecation = false;\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        schema: [\n            {\n                \"enum\": [\"always\", \"methods\", \"properties\", \"never\"]\n            }\n        ]\n    },\n    create: function() {\n        return {\n            Program: function() {\n                if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n                    return;\n                }\n\n                /* eslint-disable no-console */\n                console.log('The babel/object-shorthand rule is deprecated. Please ' +\n                            'use the built in object-shorthand rule instead.');\n                /* eslint-enable no-console */\n                isWarnedForDeprecation = true;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/arrow-parens.js":"\"use strict\";\n\nvar isWarnedForDeprecation = false;\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        schema: [\n            {\n                \"enum\": [\"always\", \"as-needed\"]\n            }\n        ]\n    },\n    create: function() {\n        return {\n            Program: function() {\n                if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n                    return;\n                }\n\n                /* eslint-disable no-console */\n                console.log('The babel/arrow-parens rule is deprecated. Please ' +\n                            'use the built in arrow-parens rule instead.');\n                /* eslint-enable no-console */\n                isWarnedForDeprecation = true;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/no-await-in-loop.js":"\"use strict\";\n\nvar isWarnedForDeprecation = false;\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        schema: []\n    },\n    create: function() {\n        return {\n            Program: function() {\n                if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n                    return;\n                }\n\n                /* eslint-disable no-console */\n                console.log('The babel/no-await-in-loop rule is deprecated. Please ' +\n                            'use the built in no-await-in-loop rule instead.');\n                /* eslint-enable no-console */\n                isWarnedForDeprecation = true;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/flow-object-type.js":"\"use strict\";\n\nvar isWarnedForDeprecation = false;\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        schema: [\n            {\n                \"enum\": [\"semicolon\", \"comma\"],\n            }\n        ]\n    },\n    create: function() {\n        return {\n            Program: function() {\n                if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n                    return;\n                }\n\n                /* eslint-disable no-console */\n                console.log('The babel/flow-object-type rule is deprecated. Please ' +\n                            'use the flowtype/object-type-delimiter rule instead.\\n' +\n                            'Check out https://github.com/gajus/eslint-plugin-flowtype#eslint-plugin-flowtype-rules-object-type-delimiter');\n                /* eslint-enable no-console */\n                isWarnedForDeprecation = true;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/func-params-comma-dangle.js":"'use strict';\n\nvar isWarnedForDeprecation = false;\nmodule.exports = {\n    meta: {\n        deprecated: true,\n        schema: [\n            {\n                \"enum\": [\"always\", \"always-multiline\", \"only-multiline\", \"never\"]\n            }\n        ]\n    },\n    create: function() {\n        return {\n            Program: function() {\n                if (isWarnedForDeprecation || /\\=-(f|-format)=/.test(process.argv.join('='))) {\n                    return;\n                }\n\n                /* eslint-disable no-console */\n                console.log('The babel/func-params-comma-dangle rule is deprecated. Please ' +\n                            'use the built in comma-dangle rule instead.');\n                /* eslint-enable no-console */\n                isWarnedForDeprecation = true;\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/no-invalid-this.js":"/**\n * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `this` keywords outside of classes or class-like objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create(context) {\n        const stack = [],\n            sourceCode = context.getSourceCode();\n\n        let insideClassProperty = false;\n\n        /**\n         * Gets the current checking context.\n         *\n         * The return value has a flag that whether or not `this` keyword is valid.\n         * The flag is initialized when got at the first time.\n         *\n         * @returns {{valid: boolean}}\n         *   an object which has a flag that whether or not `this` keyword is valid.\n         */\n        stack.getCurrent = function() {\n            const current = this[this.length - 1];\n\n            if (!current.init) {\n                current.init = true;\n                current.valid = !astUtils.isDefaultThisBinding(\n                    current.node,\n                    sourceCode);\n            }\n            return current;\n        };\n\n        /**\n         * `this` should be fair game anywhere inside a class property.\n         *\n         * @returns {void}\n         */\n        function enterClassProperty() {\n            insideClassProperty = true;\n        }\n\n        /**\n         * Back to the normal check.\n         * @returns {void}\n         */\n        function exitClassProperty() {\n            insideClassProperty = false;\n        }\n\n        /**\n         * Pushs new checking context into the stack.\n         *\n         * The checking context is not initialized yet.\n         * Because most functions don't have `this` keyword.\n         * When `this` keyword was found, the checking context is initialized.\n         *\n         * @param {ASTNode} node - A function node that was entered.\n         * @returns {void}\n         */\n        function enterFunction(node) {\n\n            // `this` can be invalid only under strict mode.\n            stack.push({\n                init: !context.getScope().isStrict,\n                node,\n                valid: true\n            });\n        }\n\n        /**\n         * Pops the current checking context from the stack.\n         * @returns {void}\n         */\n        function exitFunction() {\n            stack.pop();\n        }\n\n        return {\n\n            /*\n             * `this` is invalid only under strict mode.\n             * Modules is always strict mode.\n             */\n            Program(node) {\n                const scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {};\n\n                stack.push({\n                    init: true,\n                    node,\n                    valid: !(\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict)\n                    )\n                });\n            },\n\n            \"Program:exit\"() {\n                stack.pop();\n            },\n\n            ClassProperty: enterClassProperty,\n            \"ClassProperty:exit\": exitClassProperty,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            FunctionExpression: enterFunction,\n            \"FunctionExpression:exit\": exitFunction,\n\n            // Reports if `this` of the current context is invalid.\n            ThisExpression(node) {\n                const current = stack.getCurrent();\n\n                if (!insideClassProperty && current && !current.valid) {\n                    context.report(node, \"Unexpected 'this'.\");\n                }\n            }\n        };\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/ast-utils.js":"/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/;\nconst arrayOrTypedArrayPattern = /Array$/;\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;\nconst breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;\nconst thisTagPattern = /^[\\s\\*]*@this/m;\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference - A reference to check.\n * @param {int} index - The index of the reference in the references.\n * @param {Reference[]} references - The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n    const identifier = reference.identifier;\n\n    /*\n     * Destructuring assignments can have multiple default value, so\n     * possibly there are multiple writeable references for the same\n     * identifier.\n     */\n    const modifyingDifferentIdentifier = index === 0 ||\n        references[index - 1].identifier !== identifier;\n\n    return (identifier &&\n        reference.init === false &&\n        reference.isWrite() &&\n        modifyingDifferentIdentifier\n    );\n}\n\n/**\n * Checks whether the given string starts with uppercase or not.\n *\n * @param {string} s - The string to check.\n * @returns {boolean} `true` if the string starts with uppercase.\n */\nfunction startsWithUpperCase(s) {\n    return s[0] !== s[0].toLocaleLowerCase();\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node - A function node to check.\n * @returns {boolean} Wehether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (node.id && startsWithUpperCase(node.id.name));\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node - A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    while (node) {\n        if (anyFunctionPattern.test(node.type)) {\n            return node;\n        }\n        node = node.parent;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n    return (\n        (node.type === \"Literal\" && node.value === null) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Checks whether or not a node is `Reclect.apply`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Reclect.apply`.\n */\nfunction isReflectApply(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        node.object.name === \"Reflect\" &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"apply\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        arrayOrTypedArrayPattern.test(node.object.name) &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"from\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\nfunction isMethodWhichHasThisArg(node) {\n    while (node) {\n        if (node.type === \"Identifier\") {\n            return arrayMethodPattern.test(node.name);\n        }\n        if (node.type === \"MemberExpression\" && !node.computed) {\n            node = node.property;\n            continue;\n        }\n\n        break;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node - A node to check.\n * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n    const jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n        return true;\n    }\n\n    // Checks `@this` in its leading comments for callbacks,\n    // because callbacks don't have its JSDoc comment.\n    // e.g.\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n    return sourceCode.getComments(node).leading.some(function(comment) {\n        return thisTagPattern.test(comment.value);\n    });\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n    const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n\n    return Boolean(previousToken && nextToken) &&\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     * @public\n     */\n    isTokenOnSameLine(left, right) {\n        return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined,\n    isCallee,\n    isES5Constructor,\n    getUpperFunction,\n    isArrayFromMethod,\n    isParenthesised,\n\n    /**\n     * Checks whether or not a given node is a string literal.\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is a string literal.\n     */\n    isStringLiteral(node) {\n        return (\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\n            node.type === \"TemplateLiteral\"\n        );\n    },\n\n    /**\n     * Checks whether a given node is a breakable statement or not.\n     * The node is breakable if the node is one of the following type:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - SwitchStatement\n     * - WhileStatement\n     *\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is breakable.\n     */\n    isBreakableStatement(node) {\n        return breakableTypePattern.test(node.type);\n    },\n\n    /**\n     * Gets the label if the parent node of a given node is a LabeledStatement.\n     *\n     * @param {ASTNode} node - A node to get.\n     * @returns {string|null} The label or `null`.\n     */\n    getLabel(node) {\n        if (node.parent.type === \"LabeledStatement\") {\n            return node.parent.label.name;\n        }\n        return null;\n    },\n\n    /**\n     * Gets references which are non initializer and writable.\n     * @param {Reference[]} references - An array of references.\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\n     * @public\n     */\n    getModifyingReferences(references) {\n        return references.filter(isModifyingReference);\n    },\n\n    /**\n     * Validate that a string passed in is surrounded by the specified character\n     * @param  {string} val The text to check.\n     * @param  {string} character The character to see if it's surrounded by.\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\n     * @private\n     */\n    isSurroundedBy(val, character) {\n        return val[0] === character && val[val.length - 1] === character;\n    },\n\n    /**\n     * Returns whether the provided node is an ESLint directive comment or not\n     * @param {LineComment|BlockComment} node The node to be checked\n     * @returns {boolean} `true` if the node is an ESLint directive comment\n     */\n    isDirectiveComment(node) {\n        const comment = node.value.trim();\n\n        return (\n            node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 ||\n            node.type === \"Block\" && (\n                comment.indexOf(\"global \") === 0 ||\n                comment.indexOf(\"eslint \") === 0 ||\n                comment.indexOf(\"eslint-\") === 0\n            )\n        );\n    },\n\n    /**\n     * Finds the variable by a given name in a given scope and its upper scopes.\n     *\n     * @param {escope.Scope} initScope - A scope to start find.\n     * @param {string} name - A variable name to find.\n     * @returns {escope.Variable|null} A found variable or `null`.\n     */\n    getVariableByName(initScope, name) {\n        let scope = initScope;\n\n        while (scope) {\n            const variable = scope.set.get(name);\n\n            if (variable) {\n                return variable;\n            }\n\n            scope = scope.upper;\n        }\n\n        return null;\n    },\n\n    /**\n     * Checks whether or not a given function node is the default `this` binding.\n     *\n     * First, this checks the node:\n     *\n     * - The function name does not start with uppercase (it's a constructor).\n     * - The function does not have a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is not on an object literal.\n     * - The location is not assigned to a variable which starts with an uppercase letter.\n     * - The location is not on an ES2015 class.\n     * - Its `bind`/`call`/`apply` method is not called directly.\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     *\n     * @param {ASTNode} node - A function node to check.\n     * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n     * @returns {boolean} The function node is the default `this` binding.\n     */\n    isDefaultThisBinding(node, sourceCode) {\n        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n            return false;\n        }\n        const isAnonymous = node.id === null;\n\n        while (node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n\n                /*\n                 * Looks up the destination.\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\n                 */\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                    node = parent;\n                    break;\n\n                // If the upper function is IIFE, checks the destination of the return value.\n                // e.g.\n                //   obj.foo = (function() {\n                //     // setup...\n                //     return function foo() { ... };\n                //   })();\n                case \"ReturnStatement\": {\n                    const func = getUpperFunction(parent);\n\n                    if (func === null || !isCallee(func)) {\n                        return true;\n                    }\n                    node = func.parent;\n                    break;\n                }\n\n                // e.g.\n                //   var obj = { foo() { ... } };\n                //   var obj = { foo: function() { ... } };\n                //   class A { constructor() { ... } }\n                //   class A { foo() { ... } }\n                //   class A { get foo() { ... } }\n                //   class A { set foo() { ... } }\n                //   class A { static foo() { ... } }\n                case \"Property\":\n                case \"MethodDefinition\":\n                    return parent.value !== node;\n\n                // e.g.\n                //   obj.foo = function foo() { ... };\n                //   Foo = function() { ... };\n                //   [obj.foo = function foo() { ... }] = a;\n                //   [Foo = function() { ... }] = a;\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    if (parent.right === node) {\n                        if (parent.left.type === \"MemberExpression\") {\n                            return false;\n                        }\n                        if (isAnonymous &&\n                            parent.left.type === \"Identifier\" &&\n                            startsWithUpperCase(parent.left.name)\n                        ) {\n                            return false;\n                        }\n                    }\n                    return true;\n\n                // e.g.\n                //   var Foo = function() { ... };\n                case \"VariableDeclarator\":\n                    return !(\n                        isAnonymous &&\n                        parent.init === node &&\n                        parent.id.type === \"Identifier\" &&\n                        startsWithUpperCase(parent.id.name)\n                    );\n\n                // e.g.\n                //   var foo = function foo() { ... }.bind(obj);\n                //   (function foo() { ... }).call(obj);\n                //   (function foo() { ... }).apply(obj, []);\n                case \"MemberExpression\":\n                    return (\n                        parent.object !== node ||\n                        parent.property.type !== \"Identifier\" ||\n                        !bindOrCallOrApplyPattern.test(parent.property.name) ||\n                        !isCallee(parent) ||\n                        parent.parent.arguments.length === 0 ||\n                        isNullOrUndefined(parent.parent.arguments[0])\n                    );\n\n                // e.g.\n                //   Reflect.apply(function() {}, obj, []);\n                //   Array.from([], function() {}, obj);\n                //   list.forEach(function() {}, obj);\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[0] !== node ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFromMethod(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[1] !== node ||\n                            isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 2 ||\n                            parent.arguments[0] !== node ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return true;\n\n                // Otherwise `this` is default.\n                default:\n                    return true;\n            }\n        }\n\n        /* istanbul ignore next */\n        return true;\n    },\n\n    /**\n     * Get the precedence level based on the node type\n     * @param {ASTNode} node node to evaluate\n     * @returns {int} precedence level\n     * @private\n     */\n    getPrecedence(node) {\n        switch (node.type) {\n            case \"SequenceExpression\":\n                return 0;\n\n            case \"AssignmentExpression\":\n            case \"ArrowFunctionExpression\":\n            case \"YieldExpression\":\n                return 1;\n\n            case \"ConditionalExpression\":\n                return 3;\n\n            case \"LogicalExpression\":\n                switch (node.operator) {\n                    case \"||\":\n                        return 4;\n                    case \"&&\":\n                        return 5;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"BinaryExpression\":\n\n                switch (node.operator) {\n                    case \"|\":\n                        return 6;\n                    case \"^\":\n                        return 7;\n                    case \"&\":\n                        return 8;\n                    case \"==\":\n                    case \"!=\":\n                    case \"===\":\n                    case \"!==\":\n                        return 9;\n                    case \"<\":\n                    case \"<=\":\n                    case \">\":\n                    case \">=\":\n                    case \"in\":\n                    case \"instanceof\":\n                        return 10;\n                    case \"<<\":\n                    case \">>\":\n                    case \">>>\":\n                        return 11;\n                    case \"+\":\n                    case \"-\":\n                        return 12;\n                    case \"*\":\n                    case \"/\":\n                    case \"%\":\n                        return 13;\n\n                    // no default\n                }\n\n                /* falls through */\n\n            case \"UnaryExpression\":\n            case \"AwaitExpression\":\n                return 14;\n\n            case \"UpdateExpression\":\n                return 15;\n\n            case \"CallExpression\":\n\n                // IIFE is allowed to have parens in any position (#655)\n                if (node.callee.type === \"FunctionExpression\") {\n                    return -1;\n                }\n                return 16;\n\n            case \"NewExpression\":\n                return 17;\n\n            // no default\n        }\n        return 18;\n    },\n\n    /**\n     * Checks whether a given node is a loop node or not.\n     * The following types are loop nodes:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - WhileStatement\n     *\n     * @param {ASTNode|null} node - A node to check.\n     * @returns {boolean} `true` if the node is a loop node.\n     */\n    isLoop(node) {\n        return Boolean(node && anyLoopPattern.test(node.type));\n    },\n\n    /**\n     * Checks whether a given node is a function node or not.\n     * The following types are function nodes:\n     *\n     * - ArrowFunctionExpression\n     * - FunctionDeclaration\n     * - FunctionExpression\n     *\n     * @param {ASTNode|null} node - A node to check.\n     * @returns {boolean} `true` if the node is a function node.\n     */\n    isFunction(node) {\n        return Boolean(node && anyFunctionPattern.test(node.type));\n    },\n\n    /**\n     * Gets the property name of a given node.\n     * The node can be a MemberExpression, a Property, or a MethodDefinition.\n     *\n     * If the name is dynamic, this returns `null`.\n     *\n     * For examples:\n     *\n     *     a.b           // => \"b\"\n     *     a[\"b\"]        // => \"b\"\n     *     a['b']        // => \"b\"\n     *     a[`b`]        // => \"b\"\n     *     a[100]        // => \"100\"\n     *     a[b]          // => null\n     *     a[\"a\" + \"b\"]  // => null\n     *     a[tag`b`]     // => null\n     *     a[`${b}`]     // => null\n     *\n     *     let a = {b: 1}            // => \"b\"\n     *     let a = {[\"b\"]: 1}        // => \"b\"\n     *     let a = {['b']: 1}        // => \"b\"\n     *     let a = {[`b`]: 1}        // => \"b\"\n     *     let a = {[100]: 1}        // => \"100\"\n     *     let a = {[b]: 1}          // => null\n     *     let a = {[\"a\" + \"b\"]: 1}  // => null\n     *     let a = {[tag`b`]: 1}     // => null\n     *     let a = {[`${b}`]: 1}     // => null\n     *\n     * @param {ASTNode} node - The node to get.\n     * @returns {string|null} The property name if static. Otherwise, null.\n     */\n    getStaticPropertyName(node) {\n        let prop;\n\n        switch (node && node.type) {\n            case \"Property\":\n            case \"MethodDefinition\":\n                prop = node.key;\n                break;\n\n            case \"MemberExpression\":\n                prop = node.property;\n                break;\n\n            // no default\n        }\n\n        switch (prop && prop.type) {\n            case \"Literal\":\n                return String(prop.value);\n\n            case \"TemplateLiteral\":\n                if (prop.expressions.length === 0 && prop.quasis.length === 1) {\n                    return prop.quasis[0].value.cooked;\n                }\n                break;\n\n            case \"Identifier\":\n                if (!node.computed) {\n                    return prop.name;\n                }\n                break;\n\n            // no default\n        }\n\n        return null;\n    },\n\n    /**\n     * Get directives from directive prologue of a Program or Function node.\n     * @param {ASTNode} node - The node to check.\n     * @returns {ASTNode[]} The directives found in the directive prologue.\n     */\n    getDirectivePrologue(node) {\n        const directives = [];\n\n        // Directive prologues only occur at the top of files or functions.\n        if (\n            node.type === \"Program\" ||\n            node.type === \"FunctionDeclaration\" ||\n            node.type === \"FunctionExpression\" ||\n\n            // Do not check arrow functions with implicit return.\n            // `() => \"use strict\";` returns the string `\"use strict\"`.\n            (node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")\n        ) {\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n            for (const statement of statements) {\n                if (\n                    statement.type === \"ExpressionStatement\" &&\n                    statement.expression.type === \"Literal\"\n                ) {\n                    directives.push(statement);\n                } else {\n                    break;\n                }\n            }\n        }\n\n        return directives;\n    },\n\n\n    /**\n     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\n     after the node will be parsed as a decimal point, rather than a property-access dot.\n     * @param {ASTNode} node - The node to check.\n     * @returns {boolean} `true` if this node is a decimal integer.\n     * @example\n     *\n     * 5       // true\n     * 5.      // false\n     * 5.0     // false\n     * 05      // false\n     * 0x5     // false\n     * 0b101   // false\n     * 0o5     // false\n     * 5e0     // false\n     * '5'     // false\n     */\n    isDecimalInteger(node) {\n        return node.type === \"Literal\" && typeof node.value === \"number\" && /^(0|[1-9]\\d*)$/.test(node.raw);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-eslint-plugin-babel/node_modules/eslint-plugin-babel/rules/semi.js":"/**\n * @fileoverview Rule to flag missing semicolons.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow semicolons instead of ASI\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"never\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"always\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                omitLastInOneLineBlock: { type: \"boolean\" }\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create(context) {\n\n        const OPT_OUT_PATTERN = /^[-[(/+`]/; // One of [(/+-`\n        const options = context.options[1];\n        const never = context.options[0] === \"never\",\n            exceptOneLine = options && options.omitLastInOneLineBlock === true,\n            sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports a semicolon error with appropriate location and message.\n         * @param {ASTNode} node The node with an extra or missing semicolon.\n         * @param {boolean} missing True if the semicolon is missing.\n         * @returns {void}\n         */\n        function report(node, missing) {\n            const lastToken = sourceCode.getLastToken(node);\n            let message,\n                fix,\n                loc = lastToken.loc;\n\n            if (!missing) {\n                message = \"Missing semicolon.\";\n                loc = loc.end;\n                fix = function(fixer) {\n                    return fixer.insertTextAfter(lastToken, \";\");\n                };\n            } else {\n                message = \"Extra semicolon.\";\n                loc = loc.start;\n                fix = function(fixer) {\n                    return fixer.remove(lastToken);\n                };\n            }\n\n            context.report({\n                node,\n                loc,\n                message,\n                fix\n            });\n\n        }\n\n        /**\n         * Checks whether a token is a semicolon punctuator.\n         * @param {Token} token The token.\n         * @returns {boolean} True if token is a semicolon punctuator.\n         */\n        function isSemicolon(token) {\n            return (token.type === \"Punctuator\" && token.value === \";\");\n        }\n\n        /**\n         * Check if a semicolon is unnecessary, only true if:\n         *   - next token is on a new line and is not one of the opt-out tokens\n         *   - next token is a valid statement divider\n         * @param {Token} lastToken last token of current node.\n         * @returns {boolean} whether the semicolon is unnecessary.\n         */\n        function isUnnecessarySemicolon(lastToken) {\n            if (!isSemicolon(lastToken)) {\n                return false;\n            }\n\n            const nextToken = sourceCode.getTokenAfter(lastToken);\n\n            if (!nextToken) {\n                return true;\n            }\n\n            const lastTokenLine = lastToken.loc.end.line;\n            const nextTokenLine = nextToken.loc.start.line;\n            const isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value) && nextToken.value !== \"++\" && nextToken.value !== \"--\";\n            const isDivider = (nextToken.value === \"}\" || nextToken.value === \";\");\n\n            return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;\n        }\n\n        /**\n         * Checks a node to see if it's in a one-liner block statement.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is in a one-liner block statement.\n         */\n        function isOneLinerBlock(node) {\n            const nextToken = sourceCode.getTokenAfter(node);\n\n            if (!nextToken || nextToken.value !== \"}\") {\n                return false;\n            }\n\n            const parent = node.parent;\n\n            return parent && parent.type === \"BlockStatement\" &&\n              parent.loc.start.line === parent.loc.end.line;\n        }\n\n        /**\n         * Checks a node to see if it's followed by a semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolon(node) {\n            const lastToken = sourceCode.getLastToken(node);\n\n            if (never) {\n                if (isUnnecessarySemicolon(lastToken)) {\n                    report(node, true);\n                }\n            } else {\n                if (!isSemicolon(lastToken)) {\n                    if (!exceptOneLine || !isOneLinerBlock(node)) {\n                        report(node);\n                    }\n                } else {\n                    if (exceptOneLine && isOneLinerBlock(node)) {\n                        report(node, true);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks to see if there's a semicolon after a variable declaration.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkForSemicolonForVariableDeclaration(node) {\n            const ancestors = context.getAncestors(),\n                parentIndex = ancestors.length - 1,\n                parent = ancestors[parentIndex];\n\n            if ((parent.type !== \"ForStatement\" || parent.init !== node) &&\n                (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)\n            ) {\n                checkForSemicolon(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForSemicolonForVariableDeclaration,\n            ExpressionStatement: checkForSemicolon,\n            ReturnStatement: checkForSemicolon,\n            ThrowStatement: checkForSemicolon,\n            DoWhileStatement: checkForSemicolon,\n            DebuggerStatement: checkForSemicolon,\n            BreakStatement: checkForSemicolon,\n            ContinueStatement: checkForSemicolon,\n            ImportDeclaration: checkForSemicolon,\n            ExportAllDeclaration: checkForSemicolon,\n            ClassProperty: checkForSemicolon,\n            ExportNamedDeclaration(node) {\n                if (!node.declaration) {\n                    checkForSemicolon(node);\n                }\n            },\n            ExportDefaultDeclaration(node) {\n                if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {\n                    checkForSemicolon(node);\n                }\n            }\n        };\n\n    }\n};\n"}